{
  // common service configuration
  "Common": {
    "RootDirectory": "d:\\TEMP\\Screenshots",
    "KeepPeriod": 48, // in hours
    "CleanObsoleteFiles": true,
    "SignEnabled": false,
    "KeyPath": "\\keys\\certificate_with_private.cer",
    "DiskFreeSpaceQuota": 4096, // Disk free space quota (in kilobytes) 
    "LighterEnabled": true 
  },
  "Transmitter": {
    "ZeroMQRouter": "@tcp://127.0.0.1:10000"
  },

  // lightener configuration
  "Lightener": {
    "LighterEnabled": true,
    "JPEGQuality": 30,
    "Brightness": 3,
    "Locality": 4,
    "ContrastPlus": -2,
    "BrightnessEquAlgorithm": false,
    "Saturation": 0,
    "CompressForLighter": false,
    "Radius": 15, /* Radius задаёт радиус фильтра (расстояние от фильтруемого пиксела до границы области, по которой происходит усреденение). Если задан Radius=1, область усреднения - блок 3х3 (9 пикселов), если 2, то 5х5 (25 пикселов), если 3, то 7х7 (49 пикселов) и т.д. Обычно Radius=2 даёт приемлемые результаты. Задавать большИе значения нецелесообразно, т.к. изображение на краях не фильтруется, а ширина краёв равна Radius. Чтобы избавиться от непрофильтрованных краёв, изображение целесообразно скопировать в буфер "с рамкой" шириной Radius или Radius+1, а после фильтрации вырезать. Использование больших значений Radius (Radius>5, область усреднения >121 пиксела) нецелесообразно по крайней мере по двум причинам:1. эффективность фильтрации снижается из-за относительно больших значений локальной дисперсии при таких Radius'ах; 2. вокруг резких границ появляются ореолы непрофильтрованных пикселов. Рекомендация относительно выбора Radius, т.о. может быть такой: 1, 2, максимум - 3. 4 или 5 - для любителей экспериментов */
    "Weight": 0.5 /* Weight определяет удельный вес оригинального пиксела при фильтрации (т.е. мощность фильтра). Значение Weight = 0.001. задаёт наивысшую мощность (для очень шумных изображений: шум удаляется но изображение выглядит очень заглаженным, хотя и с резкими границами). Если задать Weight = 1., разница между исходным и профильтрованным изображением практически незаметна. */
  },

  // logging configuration
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": {
      "Default": "Debug",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "Enrich": [ "FromLogContext", "WithProcessId", "WithThreadId", "WithMachineName", "WithEnvironmentUserName" ],
    "WriteTo": [
      { "Name": "ColoredConsole" },
      { "Name": "Debug" },
      {
        "Name": "File",
        "Args": {
          //"formatter": "Serilog.Formatting.Compact.CompactJsonFormatter, Serilog",   // "Serilog.Formatting.Json.JsonFormatter, Serilog" - obsolete
          "path": "Logs\\ScreenShotDB\\%USERDNSDOMAIN%..log",
          // "restrictedToMinimumLevel": null, // The minimum level for events passed through the sink. Ignored when "levelSwitch" is specified.
          // "levelSwitch": null,  // A switch allowing the pass-through minimum level to be changed at runtime.
          "rollingInterval": "Day", // "Hour", "Month", "Year", "Infinite", "Minute" etc.
          "fileSizeLimitBytes": 104857600, // The approximate maximum size, in bytes, to which a log file will be allowed to grow. For unrestricted growth, pass null. The default is 1 GB. To avoid writing partial events, the last event within the limit will be written in full even if it exceeds the limit.
          "buffered": false, // Indicates if flushing to the output file can be buffered or not. The default is false.
          "shared": true, // Allow the log file to be shared by multiple processes. The default is false.
          // "flushToDiskInterval": null, // If provided, a full disk flush will be performed periodically at the specified interval.
          // "rollOnFileSizeLimit": null, // If <code>true</code>, a new file will be created when the file size limit is reached. Filenames will have a number appended in the format <code>_NNN</code>, with the first filename given no number.
          // "retainedFileCountLimit": null, // The maximum number of log files that will be retained, including the current log file. For unlimited retention, pass null. The default is 31.
          // "encoding": null, // Character encoding used to write the text file. The default is UTF-8 without BOM.
          // "hooks": null,  // Optionally enables hooking into log file lifecycle events.
          "outputTemplate": "{Timestamp:dd-MMM-yyyy HH:mm:ss.fff zzz} [{MachineName}:{EnvironmentUserName}][{ProcessId}:{ThreadId}] [{Level:u3}][{Application}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ],
    "Properties": {
      "Application": "EpisodeStorage"
    }
  }
}
